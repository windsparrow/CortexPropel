<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CortexPropel - 任务全景视图</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #6366f1;
            /* Indigo 500 */
            --primary-glow: rgba(99, 102, 241, 0.4);
            --bg-color: #f8fafc;
            /* Slate 50 */
            --panel-bg: rgba(255, 255, 255, 0.9);
            --text-main: #1e293b;
            /* Slate 800 */
            --text-secondary: #64748b;
            /* Slate 500 */
            --border-color: #e2e8f0;
            /* Slate 200 */

            --status-pending: #f59e0b;
            /* Amber 500 */
            --status-completed: #10b981;
            /* Emerald 500 */
            --status-inprogress: #3b82f6;
            /* Blue 500 */
            --status-failed: #ef4444;
            /* Red 500 */
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-main);
            overflow: hidden;
            /* App-like feel */
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .glass-header {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        .brand h1 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-main);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .brand span.subtitle {
            font-weight: 400;
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-left: 0.5rem;
            padding-left: 0.5rem;
            border-left: 1px solid var(--border-color);
        }

        .stats-pills {
            display: flex;
            gap: 1rem;
        }

        .stat-pill {
            background: #fff;
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            /* Pill shape */
            border: 1px solid var(--border-color);
            font-size: 0.85rem;
            display: flex;
            gap: 0.5rem;
            align-items: center;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .stat-pill span.val {
            font-weight: 600;
            color: var(--primary-color);
        }

        /* Main Content */
        .workspace {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        /* Tree Visualization Area */
        .vis-container {
            flex: 1;
            position: relative;
            background-image:
                radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 24px 24px;
            cursor: grab;
        }

        .vis-container:active {
            cursor: grabbing;
        }

        /* Side Panel */
        .side-panel {
            width: 400px;
            background: var(--panel-bg);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.05);
            z-index: 5;
            transition: transform 0.3s ease;
        }

        .panel-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .panel-header h2 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 0 1.5rem 1.5rem 1.5rem;
        }

        /* Tasks List Styles */
        .task-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .task-card {
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .task-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            border-color: var(--primary-color);
        }

        .task-card.active {
            border-color: var(--primary-color);
            background-color: #f0f7ff;
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.5rem;
            gap: 1rem;
        }

        .task-title {
            font-size: 1rem;
            font-weight: 600;
            margin: 0;
            line-height: 1.3;
            color: var(--text-main);
            flex: 1;
        }

        .task-status {
            font-size: 0.65rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 2px 6px;
            border-radius: 4px;
            background: #f8fafc;
            border: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .task-desc {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            line-height: 1.5;
        }

        .task-meta-footer {
            display: flex;
            justify-content: flex-end;
            border-top: 1px solid #f1f5f9;
            padding-top: 0.5rem;
        }

        .task-id {
            font-family: 'Monaco', monospace;
            font-size: 0.7rem;
            color: #94a3b8;
        }

        /* SVG Styles */
        #tree-svg {
            width: 100%;
            height: 100%;
        }

        .node-rect {
            fill: #fff;
            stroke-width: 2px;
            transition: all 0.3s ease;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.05));
        }

        .node-rect.highlighted {
            filter: drop-shadow(0 0 8px var(--primary-glow));
        }

        .node text {
            font-family: 'Inter', sans-serif;
            fill: var(--text-main);
            pointer-events: none;
        }

        .node-title {
            font-weight: 600;
            font-size: 13px;
        }

        .node-id {
            font-size: 10px;
            fill: var(--text-secondary);
            font-family: 'Monaco', monospace;
        }

        .link {
            fill: none;
            stroke: #cbd5e1;
            stroke-width: 1.5px;
            transition: all 0.3s;
        }

        /* Controls */
        .controls {
            position: absolute;
            bottom: 2rem;
            left: 2rem;
            background: white;
            padding: 0.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 0.5rem;
        }

        .control-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            width: 32px;
            height: 32px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-main);
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: #f8fafc;
            border-color: var(--text-secondary);
        }

        /* Status Indicators */
        /* Status Colors */
        .color-pending {
            stroke: var(--status-pending);
        }

        .fill-pending {
            fill: var(--status-pending);
        }

        .text-pending {
            color: var(--status-pending);
        }

        .color-completed {
            stroke: var(--status-completed);
        }

        .fill-completed {
            fill: var(--status-completed);
        }

        .text-completed {
            color: var(--status-completed);
        }

        .color-in-progress {
            stroke: var(--status-inprogress);
        }

        .fill-in-progress {
            fill: var(--status-inprogress);
        }

        .text-in-progress {
            color: var(--status-inprogress);
        }

        .color-failed {
            stroke: var(--status-failed);
        }

        .fill-failed {
            fill: var(--status-failed);
        }

        .text-failed {
            color: var(--status-failed);
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- Header -->
        <header class="glass-header">
            <div class="brand">
                <h1>
                    <span>✨</span>
                    CortexPropel
                    <span class="subtitle">Mission Command</span>
                </h1>
            </div>
            <div class="stats-pills">
                <div class="stat-pill">
                    <span>Total Tasks</span>
                    <span class="val" id="total-tasks">-</span>
                </div>
                <div class="stat-pill">
                    <span>Consistency</span>
                    <span class="val" id="consistency">-</span>
                </div>
            </div>
        </header>

        <!-- Workspace -->
        <div class="workspace">
            <!-- Visualization -->
            <div class="vis-container" id="vis-container">
                <svg id="tree-svg">
                    <defs>
                        <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
                            <feDropShadow dx="0" dy="2" stdDeviation="3" flood-opacity="0.1" />
                        </filter>
                    </defs>
                    <g id="vis-group"></g>
                </svg>

                <div class="controls">
                    <button class="control-btn" onclick="zoomIn()" title="Zoom In">+</button>
                    <button class="control-btn" onclick="zoomOut()" title="Zoom Out">-</button>
                    <button class="control-btn" onclick="resetZoom()" title="Reset View">⟲</button>
                </div>
            </div>

            <!-- Side Panel -->
            <div class="side-panel">
                <div class="panel-header">
                    <h2>Task Details</h2>
                </div>
                <div class="panel-content">
                    <ul class="task-list" id="tasks-list">
                        <!-- Tasks will be injected here -->
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration & State ---
        const config = {
            nodeWidth: 180,
            nodeHeight: 60,
            duration: 750,
            rootX: 100,
            rootY: 0 // Will be centered dynamically
        };

        const state = {
            treeData: null,
            tasksMap: new Map(), // ID -> Task Data
            zoomTransform: d3.zoomIdentity,
            svg: null,
            g: null,
            zoom: null
        };

        const statusColors = {
            'pending': '#f59e0b',
            'completed': '#10b981',
            'in-progress': '#3b82f6',
            'failed': '#ef4444',
            'unknown': '#94a3b8'
        };

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            initSVG();
            await loadData();
        });

        function initSVG() {
            state.svg = d3.select("#tree-svg");
            state.g = d3.select("#vis-group");

            // Setup Zoom
            state.zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on("zoom", (e) => {
                    state.g.attr("transform", e.transform);
                    state.zoomTransform = e.transform;
                });

            state.svg.call(state.zoom);

            // Initial center (approximated, will adjust after render)
            const container = document.getElementById('vis-container');
            state.zoom.translateTo(state.svg, 0, container.clientHeight / 2);
        }

        async function loadData() {
            try {
                const [treeRes, tasksRes, validateRes] = await Promise.all([
                    fetch('/api/tree'),
                    fetch('/api/tasks'),
                    fetch('/api/validate')
                ]);

                const treeJson = await treeRes.json();
                const tasksJson = await tasksRes.json();
                const validateJson = await validateRes.json();

                // Process Data
                state.treeData = treeJson.tree;

                // Build a quick lookup map
                state.tasksMap.clear();
                tasksJson.tasks.forEach(t => state.tasksMap.set(t.id, t));

                // Update Stats
                document.getElementById('total-tasks').textContent = tasksJson.total_count;
                const consistency = Math.round(validateJson.consistency_score * 100);
                document.getElementById('consistency').textContent = consistency + '%';

                // Render
                renderTree(state.treeData);
                renderTaskList(tasksJson.tasks);

            } catch (err) {
                console.error("Failed to load data:", err);
                alert("Failed to load data. See console for details.");
            }
        }

        // --- Tree Rendering ---
        function renderTree(data) {
            const root = d3.hierarchy(data, d => d.subtasks);

            // Calculate layout dimensions
            // Horizontal layout: height depends on number of leaves, width on depth
            const dx = 50; // vertical spacing between nodes (was config.nodeHeight + 30)
            const dy = 300; // horizontal spacing between levels (widened for adaptive widths)

            // Use d3.tree
            // Note: d3.tree().nodeSize([height, width]) because coordinates are flipped later? 
            // Actually, let's keep it simple. d3.tree creates x/y.
            // We want horizontal: Root at Left. 
            // In d3.tree, 'x' is usually vertical (top-to-bottom flow), 'y' is depth.
            // If we swap x and y in rendering, we get horizontal.

            const tree = d3.tree().nodeSize([dx, dy]);
            tree(root);

            // 1. Pre-calculate widths for all nodes
            root.descendants().forEach(d => {
                const title = d.data.title || "Untitled";
                // Estimate width: approx 14px per char + 40px padding
                // Cap min width at 120px, max at 400px
                d.width = Math.min(400, Math.max(120, title.length * 15 + 40));
                d.height = 40; // Fixed height
            });

            // 2. Compute tree layout (gives us x and initial y)
            tree(root);

            // 3. Adjust horizontal spacing (y) based on max width per level to prevent overlap
            const levelWidths = {};
            const levelGap = 80; // Gap between levels

            // Find max width for each depth
            root.descendants().forEach(d => {
                const depth = d.depth;
                levelWidths[depth] = Math.max(levelWidths[depth] || 0, d.width);
            });

            // Calculate cumulative offset for each depth
            const levelOffsets = {};
            let currentOffset = 0;
            // Assuming max depth is reasonable
            const maxDepth = Math.max(...Object.keys(levelWidths).map(Number));

            for (let i = 0; i <= maxDepth; i++) {
                levelOffsets[i] = currentOffset;
                // Next level starts after this level's max width + gap
                currentOffset += (levelWidths[i] || 0) + levelGap;
            }

            // Apply new y coordinates
            root.descendants().forEach(d => {
                d.y = levelOffsets[d.depth];
            });

            // Compute global min/max to auto-center
            let x0 = Infinity;
            let x1 = -x0;
            root.each(d => {
                if (d.x > x1) x1 = d.x;
                if (d.x < x0) x0 = d.x;
            });

            // Adjust root vertical position to center it
            // After swap: d.x -> vertical (y), d.y -> horizontal (x)

            // Create links
            const links = state.g.selectAll(".link")
                .data(root.links())
                .join("path")
                .attr("class", "link")
                .attr("d", d3.linkHorizontal()
                    .x(d => d.y)
                    .y(d => d.x)
                );

            const node = state.g.selectAll(".node")
                .data(root.descendants())
                .join("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.y},${d.x})`)
                .on("click", (e, d) => scrollToTask(d.data.id));

            // We use 'each' to have context for measuring text if needed, 
            // but for simplicity and performance in this update, we will use estimation.

            node.each(function (d) {
                const g = d3.select(this);
                const title = d.data.title || "Untitled";
                // Estimate width: approx 14px per char + 40px padding
                // Cap min width at 100px, max at 400px
                const estimatedWidth = Math.min(400, Math.max(120, title.length * 15 + 40));
                const height = 40;

                // Background Rectangle (Simple Light Blue Pill)
                g.append("rect")
                    .attr("class", "node-rect")
                    .attr("rx", 20) // Fully rounded ends
                    .attr("ry", 20)
                    .attr("width", estimatedWidth)
                    .attr("height", height)
                    .attr("x", 0)
                    .attr("y", -height / 2)
                    .style("fill", "#e1f5fe") // Light Blue 50
                    .style("stroke", "#039be5") // Light Blue 600
                    .style("stroke-width", "2px");

                // Status Indicator (Small colored dot on the left)
                g.append("circle")
                    .attr("cx", 20)
                    .attr("cy", 0)
                    .attr("r", 6)
                    .attr("fill", statusColors[d.data.status || 'unknown']);

                // Text: Title
                g.append("text")
                    .attr("class", "node-title")
                    .attr("x", 35) // After the dot
                    .attr("y", 5) // Centered vertically
                    .text(title)
                    .style("font-size", "14px")
                    .style("font-weight", "500")
                    .style("fill", "#01579b"); // Dark Blue text
            });

            // Auto-Layout: Center the tree
            const container = document.getElementById('vis-container');
            const h = container.clientHeight;
            const w = container.clientWidth;

            // Initial transform
            // We want the root (which is at y=0, x=some_center) to be at the left-middle.
            // d.y is horizontal (starts at 0), d.x is vertical (centered around 0ish)

            // If the tree is large, d.x can range from -Large to +Large.
            // We want to translate such that the root node is at (50, h/2).
            const initialScale = 0.9;
            const transX = 50;
            const transY = h / 2 - root.x; // Shift by root's x-coordinate to center it?
            // Actually, d3.tree centers children. Root x is usually the midpoint of first and last child.
            // Wait, d3.tree with nodeSize lays out relative to (0,0) usually.
            // Let's just rely on zoomToFit logic if we had one, but let's try a simple center.

            state.svg.call(state.zoom.transform, d3.zoomIdentity.translate(50, h / 2).scale(0.8));
        }

        // --- List Rendering ---
        function renderTaskList(tasks) {
            const list = document.getElementById('tasks-list');
            list.innerHTML = tasks.map(t => {
                const status = t.status || 'unknown';
                return `
                    <li class="task-card" id="card-${t.id}" onclick="focusNode('${t.id}')">
                        <div class="task-header">
                            <h3 class="task-title">${t.title || 'Untitled Task'}</h3>
                            <span class="task-status text-${status}">${status}</span>
                        </div>
                        <div class="task-desc">
                            ${truncate(t.description || '', 80)}
                        </div>
                        <div class="task-meta-footer">
                            <span class="task-id">ID: ${t.id}</span>
                        </div>
                    </li>
                `;
            }).join('');
        }

        // --- Interactions ---
        function truncate(str, n) {
            return (str && str.length > n) ? str.substr(0, n - 1) + '&hellip;' : str;
        }

        function scrollToTask(id) {
            // Highlight in list
            const card = document.getElementById(`card-${id}`);
            if (card) {
                document.querySelectorAll('.task-card').forEach(c => c.classList.remove('active'));
                card.classList.add('active');
                card.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function focusNode(id) {
            // Find node in tree
            // Since we don't have a direct map from ID to D3 Node, we search. Not efficient but fine for small trees.
            // Or we could have indexed it.
            // Let's just log for now or try to finding it
            // console.log("Focusing node", id);
        }

        function zoomIn() {
            state.svg.transition().call(state.zoom.scaleBy, 1.2);
        }

        function zoomOut() {
            state.svg.transition().call(state.zoom.scaleBy, 0.8);
        }

        function resetZoom() {
            const container = document.getElementById('vis-container');
            state.svg.transition().call(state.zoom.transform,
                d3.zoomIdentity.translate(50, container.clientHeight / 2).scale(0.8));
        }

    </script>
</body>

</html>