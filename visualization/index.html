<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CortexPropel - ‰ªªÂä°ÂÖ®ÊôØËßÜÂõæ</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #6366f1;
            /* Indigo 500 */
            --primary-glow: rgba(99, 102, 241, 0.4);
            --bg-color: #f8fafc;
            /* Slate 50 */
            --panel-bg: rgba(255, 255, 255, 0.9);
            --text-main: #1e293b;
            /* Slate 800 */
            --text-secondary: #64748b;
            /* Slate 500 */
            --border-color: #e2e8f0;
            /* Slate 200 */

            --status-pending: #f59e0b;
            /* Amber 500 */
            --status-completed: #10b981;
            /* Emerald 500 */
            --status-inprogress: #3b82f6;
            /* Blue 500 */
            --status-failed: #ef4444;
            /* Red 500 */
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-main);
            overflow: hidden;
            /* App-like feel */
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .glass-header {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        .brand h1 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-main);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .brand span.subtitle {
            font-weight: 400;
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-left: 0.5rem;
            padding-left: 0.5rem;
            border-left: 1px solid var(--border-color);
        }

        .header-actions {
            display: flex;
            gap: 1rem;
        }

        .reset-btn {
            background: #fff;
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .reset-btn:hover {
            background: #f8fafc;
            border-color: var(--text-secondary);
            color: var(--text-main);
        }

        .reset-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            font-weight: 500;
            font-size: 0.9rem;
            z-index: 1000;
            animation: slideInRight 0.3s ease, fadeOut 0.3s ease 2.7s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .toast.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .toast.error {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }

        /* Main Content */
        .workspace {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
            gap: 0;
        }

        /* Chat Panel (Left) */
        .chat-panel {
            width: 40%;
            background: var(--panel-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.05);
        }

        .message-time {
            font-size: 0.7rem;
            color: #94a3b8;
            margin-top: 0.25rem;
            font-family: 'Monaco', monospace;
        }

        .message.user .message-time {
            text-align: right;
            color: #667eea;
        }

        .message.assistant .message-time {
            text-align: left;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .message {
            display: flex;
            gap: 0.75rem;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            flex-shrink: 0;
        }

        .message.user .message-avatar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .message.assistant .message-avatar {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .message-bubble {
            max-width: 90%;
            padding: 0.75rem 1rem;
            border-radius: 12px;
            line-height: 1.5;
            font-size: 0.9rem;
        }

        .message.user .message-bubble {
            background: var(--primary-color);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message.assistant .message-bubble {
            background: #f1f5f9;
            color: var(--text-main);
            border-bottom-left-radius: 4px;
        }

        /* Report bubble styles */
        .report-bubble {
            max-width: 100%;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 1px solid #e2e8f0;
        }

        /* Markdown content styles */
        .markdown-content {
            line-height: 1.6;
        }

        .markdown-content h1 {
            font-size: 1.3rem;
            font-weight: 600;
            color: #1e293b;
            margin: 0.8em 0 0.4em;
            padding-bottom: 0.3em;
            border-bottom: 2px solid #e2e8f0;
        }

        .markdown-content h2 {
            font-size: 1.15rem;
            font-weight: 600;
            color: #334155;
            margin: 0.7em 0 0.3em;
        }

        .markdown-content h3 {
            font-size: 1.05rem;
            font-weight: 500;
            color: #475569;
            margin: 0.6em 0 0.3em;
        }

        .markdown-content h4,
        .markdown-content h5,
        .markdown-content h6 {
            font-size: 0.95rem;
            font-weight: 500;
            color: #64748b;
            margin: 0.5em 0 0.2em;
        }

        .markdown-content p {
            margin: 0.5em 0;
        }

        .markdown-content ul,
        .markdown-content ol {
            margin: 0.5em 0;
            padding-left: 1.5em;
        }

        .markdown-content li {
            margin: 0.3em 0;
        }

        .markdown-content li::marker {
            color: var(--primary-color);
        }

        .markdown-content code {
            background: #e2e8f0;
            padding: 0.15em 0.4em;
            border-radius: 4px;
            font-size: 0.85em;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .markdown-content pre {
            background: #1e293b;
            color: #e2e8f0;
            padding: 0.8em 1em;
            border-radius: 8px;
            overflow-x: auto;
            margin: 0.6em 0;
        }

        .markdown-content pre code {
            background: transparent;
            padding: 0;
            color: inherit;
        }

        .markdown-content blockquote {
            border-left: 4px solid var(--primary-color);
            background: rgba(99, 102, 241, 0.08);
            margin: 0.6em 0;
            padding: 0.5em 1em;
            border-radius: 0 8px 8px 0;
            color: #475569;
        }

        .markdown-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 0.6em 0;
            font-size: 0.9em;
        }

        .markdown-content th,
        .markdown-content td {
            border: 1px solid #e2e8f0;
            padding: 0.5em 0.8em;
            text-align: left;
        }

        .markdown-content th {
            background: #f1f5f9;
            font-weight: 600;
            color: #334155;
        }

        .markdown-content tr:nth-child(even) {
            background: #f8fafc;
        }

        .markdown-content strong {
            color: #1e40af;
            font-weight: 600;
        }

        .markdown-content em {
            color: #7c3aed;
        }

        .markdown-content hr {
            border: none;
            border-top: 1px solid #e2e8f0;
            margin: 1em 0;
        }

        .markdown-content a {
            color: var(--primary-color);
            text-decoration: none;
        }

        .markdown-content a:hover {
            text-decoration: underline;
        }

        .chat-input-area {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border-color);
            background: white;
        }

        .chat-input-container {
            display: flex;
            gap: 0.75rem;
            align-items: flex-end;
        }

        .chat-input {
            flex: 1;
            padding: 0.75rem 1rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-family: inherit;
            font-size: 0.9rem;
            resize: none;
            max-height: 120px;
            transition: border-color 0.2s;
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .send-btn {
            padding: 0.75rem 1.5rem;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .send-btn:hover:not(:disabled) {
            background: #5558e3;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Right Panel Container */
        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Tree Visualization Area */
        .vis-container {
            flex: 60;
            position: relative;
            background-image:
                radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 24px 24px;
            cursor: grab;
            border-bottom: 1px solid var(--border-color);
        }

        .vis-container:active {
            cursor: grabbing;
        }

        /* Task List Panel (Bottom Right) */
        .task-list-panel {
            flex: 40;
            background: var(--panel-bg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            background: white;
        }

        .panel-header h2 {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 1.5rem;
        }

        /* Task Table Styles */
        .task-table-container {
            overflow-x: auto;
            background: white;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .task-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        .task-table thead {
            background: #f8fafc;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .task-table th {
            padding: 0.75rem 1rem;
            text-align: left;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 2px solid var(--border-color);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .task-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #f1f5f9;
            color: var(--text-main);
        }

        .task-table tbody tr {
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .task-table tbody tr:hover {
            background: #f8fafc;
        }

        .task-table tbody tr.active {
            background: #f0f7ff;
            border-left: 3px solid var(--primary-color);
        }

        .task-title-cell {
            font-weight: 500;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .task-desc-cell {
            max-width: 250px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            color: var(--text-secondary);
            font-size: 0.8rem;
        }

        .task-status-badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .status-pending {
            background: #fef3c7;
            color: #92400e;
        }

        .status-in-progress,
        .status-in_progress {
            background: #dbeafe;
            color: #1e40af;
        }

        .status-completed {
            background: #d1fae5;
            color: #065f46;
        }

        .status-failed {
            background: #fee2e2;
            color: #991b1b;
        }

        .task-id-cell {
            font-family: 'Monaco', monospace;
            font-size: 0.7rem;
            color: #94a3b8;
        }

        .task-time-cell {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        /* SVG Styles */
        #tree-svg {
            width: 100%;
            height: 100%;
        }

        .node-rect {
            fill: #fff;
            stroke-width: 2px;
            transition: all 0.3s ease;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.05));
        }

        .node-rect.highlighted {
            filter: drop-shadow(0 0 8px var(--primary-glow));
        }

        .node text {
            font-family: 'Inter', sans-serif;
            fill: var(--text-main);
            pointer-events: none;
        }

        .node-title {
            font-weight: 600;
            font-size: 13px;
        }

        .node-id {
            font-size: 10px;
            fill: var(--text-secondary);
            font-family: 'Monaco', monospace;
        }

        .link {
            fill: none;
            stroke: #cbd5e1;
            stroke-width: 1.5px;
            transition: all 0.3s;
        }

        /* Controls */
        .controls {
            position: absolute;
            bottom: 2rem;
            left: 2rem;
            background: white;
            padding: 0.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 0.5rem;
        }

        .control-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            width: 32px;
            height: 32px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-main);
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: #f8fafc;
            border-color: var(--text-secondary);
        }

        /* Status Indicators */
        /* Status Colors */
        .color-pending {
            stroke: var(--status-pending);
        }

        .fill-pending {
            fill: var(--status-pending);
        }

        .text-pending {
            color: var(--status-pending);
        }

        .color-completed {
            stroke: var(--status-completed);
        }

        .fill-completed {
            fill: var(--status-completed);
        }

        .text-completed {
            color: var(--status-completed);
        }

        .color-in-progress {
            stroke: var(--status-inprogress);
        }

        .fill-in-progress {
            fill: var(--status-inprogress);
        }

        .text-in-progress {
            color: var(--status-inprogress);
        }

        .color-failed {
            stroke: var(--status-failed);
        }

        .fill-failed {
            fill: var(--status-failed);
        }

        .text-failed {
            color: var(--status-failed);
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- Header -->
        <header class="glass-header">
            <div class="brand">
                <h1>
                    <span>‚ú®</span>
                    CortexPropel
                    <span class="subtitle">Mission Command</span>
                </h1>
            </div>
            <div class="header-actions">
                <button id="reset-btn" class="reset-btn" onclick="resetTaskTree()">
                    Reset
                </button>
            </div>
        </header>

        <!-- Workspace -->
        <div class="workspace">
            <!-- Chat Panel (Left) -->
            <div class="chat-panel">
                <div class="chat-messages" id="chat-messages">
                    <!-- Chat history will be loaded here -->
                </div>
                <div class="chat-input-area">
                    <div class="chat-input-container">
                        <textarea id="chat-input" class="chat-input" placeholder="ËæìÂÖ•Ê∂àÊÅØ..." rows="1"></textarea>
                        <button id="send-btn" class="send-btn" onclick="sendMessage()">
                            <span>ÂèëÈÄÅ</span>
                            <span>‚Üí</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Right Panel -->
            <div class="right-panel">
                <!-- Tree Visualization (Top) -->
                <div class="vis-container" id="vis-container">
                    <svg id="tree-svg">
                        <defs>
                            <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
                                <feDropShadow dx="0" dy="2" stdDeviation="3" flood-opacity="0.1" />
                            </filter>
                        </defs>
                        <g id="vis-group"></g>
                    </svg>

                    <div class="controls">
                        <button class="control-btn" onclick="zoomIn()" title="Zoom In">+</button>
                        <button class="control-btn" onclick="zoomOut()" title="Zoom Out">-</button>
                        <button class="control-btn" onclick="resetZoom()" title="Reset View">‚ü≤</button>
                    </div>
                </div>

                <!-- Task List Panel (Bottom) -->
                <div class="task-list-panel">
                    <div class="panel-header">
                        <h2>üìã ‰ªªÂä°ÂàóË°®</h2>
                    </div>
                    <div class="panel-content">
                        <div id="tasks-list">
                            <!-- Task table will be injected here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration & State ---
        const config = {
            nodeWidth: 180,
            nodeHeight: 60,
            duration: 750,
            rootX: 100,
            rootY: 0 // Will be centered dynamically
        };

        const state = {
            treeData: null,
            tasksMap: new Map(), // ID -> Task Data
            zoomTransform: d3.zoomIdentity,
            svg: null,
            g: null,
            zoom: null
        };

        const statusColors = {
            'pending': '#f59e0b',
            'completed': '#10b981',
            'in-progress': '#3b82f6',
            'failed': '#ef4444',
            'unknown': '#94a3b8'
        };

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            initSVG();
            await loadData();
            initChat();
        });

        // --- Toast Notification ---
        function showToast(message, type = 'success') {
            // Remove existing toasts
            const existingToasts = document.querySelectorAll('.toast');
            existingToasts.forEach(t => t.remove());

            // Create new toast
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            // Remove after 3 seconds
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // --- Reset Task Tree ---
        async function resetTaskTree() {
            const resetBtn = document.getElementById('reset-btn');

            // Confirm action
            if (!confirm('Á°ÆÂÆöË¶ÅÈáçÁΩÆÊâÄÊúâ‰ªªÂä°Êï∞ÊçÆÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ„ÄÇ')) {
                return;
            }

            resetBtn.disabled = true;

            try {
                const response = await fetch('/api/reset', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    showToast('‚úì Reset ÊàêÂäüÔºÅ‰ªªÂä°Ê†ëÂ∑≤ÈáçÁΩÆ', 'success');

                    // Clear chat history
                    chatHistory = [];
                    document.getElementById('chat-messages').innerHTML = '';
                    await fetch('/api/chat/history', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ messages: [] })
                    });

                    // Reload data
                    await loadData();
                } else {
                    showToast('‚úó Reset Â§±Ë¥•: ' + (data.detail || data.message), 'error');
                }
            } catch (error) {
                console.error('Reset error:', error);
                showToast('‚úó Reset Â§±Ë¥•: ÁΩëÁªúÈîôËØØ', 'error');
            } finally {
                resetBtn.disabled = false;
            }
        }

        // --- Chat Functions ---
        let chatHistory = [];

        function initChat() {
            const chatInput = document.getElementById('chat-input');

            // Load chat history
            loadChatHistory();

            // Auto-resize textarea
            chatInput.addEventListener('input', function () {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 120) + 'px';
            });

            // Send on Enter (Shift+Enter for new line)
            chatInput.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
        }

        async function loadChatHistory() {
            try {
                const response = await fetch('/api/chat/history');
                if (response.ok) {
                    const data = await response.json();
                    chatHistory = data.messages || [];

                    // Render existing messages
                    chatHistory.forEach(msg => {
                        addMessageToChat(msg.role, msg.content, msg.timestamp, false);
                    });
                }
            } catch (error) {
                console.log('No chat history found or error loading:', error);
                // Add welcome message if no history
                if (chatHistory.length === 0) {
                    const welcomeMsg = {
                        role: 'assistant',
                        content: '‰Ω†Â•ΩÔºÅÊàëÊòØ‰Ω†ÁöÑ‰ªªÂä°ÁÆ°ÁêÜÂä©Êâã„ÄÇ‰Ω†ÂèØ‰ª•ÈÄöËøáÂØπËØùÊù•Ê∑ªÂä†„ÄÅ‰øÆÊîπÊàñÊü•ËØ¢‰ªªÂä°„ÄÇ',
                        timestamp: new Date().toISOString()
                    };
                    chatHistory.push(welcomeMsg);
                    addMessageToChat(welcomeMsg.role, welcomeMsg.content, welcomeMsg.timestamp, false);
                }
            }
        }

        async function saveChatHistory() {
            try {
                await fetch('/api/chat/history', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ messages: chatHistory })
                });
            } catch (error) {
                console.error('Failed to save chat history:', error);
            }
        }

        async function sendMessage() {
            const input = document.getElementById('chat-input');
            const sendBtn = document.getElementById('send-btn');
            const message = input.value.trim();

            if (!message) return;

            // Disable input while processing
            input.disabled = true;
            sendBtn.disabled = true;

            // Add user message to chat with timestamp
            const userTimestamp = new Date().toISOString();
            chatHistory.push({ role: 'user', content: message, timestamp: userTimestamp });
            addMessageToChat('user', message, userTimestamp);
            saveChatHistory();

            // Clear input
            input.value = '';
            input.style.height = 'auto';

            try {
                // Send to backend
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ message: message })
                });

                const data = await response.json();

                if (data.success) {
                    // Add assistant response with timestamp
                    const assistantTimestamp = new Date().toISOString();
                    chatHistory.push({ role: 'assistant', content: data.message, timestamp: assistantTimestamp });
                    addMessageToChat('assistant', data.message, assistantTimestamp);

                    // If there's a report, add it as a separate message
                    if (data.report) {
                        const reportTimestamp = new Date().toISOString();
                        chatHistory.push({ role: 'assistant', content: data.report, timestamp: reportTimestamp });
                        addMessageToChat('assistant', data.report, reportTimestamp, false, true);
                    }

                    saveChatHistory();

                    // Update tree and task list
                    state.treeData = data.tree;
                    renderTree(data.tree);
                    renderTaskList(data.tasks);

                } else {
                    const errorTimestamp = new Date().toISOString();
                    const errorMsg = `ÈîôËØØ: ${data.error || 'Â§ÑÁêÜÂ§±Ë¥•'}`;
                    chatHistory.push({ role: 'assistant', content: errorMsg, timestamp: errorTimestamp });
                    addMessageToChat('assistant', errorMsg, errorTimestamp);
                    saveChatHistory();
                }
            } catch (error) {
                console.error('Chat error:', error);
                const errorTimestamp = new Date().toISOString();
                const errorMsg = 'Êä±Ê≠âÔºåÂèëÁîü‰∫ÜÈîôËØØ„ÄÇËØ∑Á®çÂêéÈáçËØï„ÄÇ';
                chatHistory.push({ role: 'assistant', content: errorMsg, timestamp: errorTimestamp });
                addMessageToChat('assistant', errorMsg, errorTimestamp);
                saveChatHistory();
            } finally {
                // Re-enable input
                input.disabled = false;
                sendBtn.disabled = false;
                input.focus();
            }
        }

        function addMessageToChat(role, content, timestamp = null, shouldSave = true, isReport = false) {
            const messagesContainer = document.getElementById('chat-messages');

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;

            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = role === 'user' ? 'üë§' : 'ü§ñ';

            const contentWrapper = document.createElement('div');

            const bubble = document.createElement('div');
            bubble.className = 'message-bubble';

            // Render Markdown for reports
            if (isReport) {
                bubble.innerHTML = renderMarkdown(content);
                bubble.classList.add('report-bubble', 'markdown-content');
            } else {
                bubble.textContent = content;
            }

            const timeDiv = document.createElement('div');
            timeDiv.className = 'message-time';
            const time = timestamp ? new Date(timestamp) : new Date();
            timeDiv.textContent = formatMessageTime(time);

            contentWrapper.appendChild(bubble);
            contentWrapper.appendChild(timeDiv);

            messageDiv.appendChild(avatar);
            messageDiv.appendChild(contentWrapper);
            messagesContainer.appendChild(messageDiv);

            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Render Markdown using marked.js library
        function renderMarkdown(text) {
            // Configure marked options
            marked.setOptions({
                breaks: true,      // Convert \n to <br>
                gfm: true,         // GitHub Flavored Markdown
                headerIds: false,  // Don't add IDs to headers
                mangle: false      // Don't mangle email addresses
            });

            try {
                return marked.parse(text);
            } catch (e) {
                console.error('Markdown parsing error:', e);
                return text.replace(/\n/g, '<br>');
            }
        }

        function formatMessageTime(date) {
            const now = new Date();
            const diff = now - date;
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (seconds < 60) return 'ÂàöÂàö';
            if (minutes < 60) return `${minutes}ÂàÜÈíüÂâç`;
            if (hours < 24) return `${hours}Â∞èÊó∂Ââç`;
            if (days < 7) return `${days}Â§©Ââç`;

            return date.toLocaleString('zh-CN', {
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function initSVG() {
            state.svg = d3.select("#tree-svg");
            state.g = d3.select("#vis-group");

            // Setup Zoom
            state.zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on("zoom", (e) => {
                    state.g.attr("transform", e.transform);
                    state.zoomTransform = e.transform;
                });

            state.svg.call(state.zoom);

            // Initial center (approximated, will adjust after render)
            const container = document.getElementById('vis-container');
            state.zoom.translateTo(state.svg, 0, container.clientHeight / 2);
        }

        async function loadData() {
            try {
                const [treeRes, tasksRes, validateRes] = await Promise.all([
                    fetch('/api/tree'),
                    fetch('/api/tasks'),
                    fetch('/api/validate')
                ]);

                const treeJson = await treeRes.json();
                const tasksJson = await tasksRes.json();
                const validateJson = await validateRes.json();

                // Process Data
                state.treeData = treeJson.tree;

                // Build a quick lookup map
                state.tasksMap.clear();
                tasksJson.tasks.forEach(t => state.tasksMap.set(t.id, t));


                // Render
                renderTree(state.treeData);
                renderTaskList(tasksJson.tasks);

            } catch (err) {
                console.error("Failed to load data:", err);
                alert("Failed to load data. See console for details.");
            }
        }

        // --- Tree Rendering ---
        function renderTree(data) {
            // Clear previous tree elements to prevent stacking
            state.g.selectAll(".node").remove();
            state.g.selectAll(".link").remove();

            const root = d3.hierarchy(data, d => d.subtasks);

            // Calculate layout dimensions
            // Horizontal layout: height depends on number of leaves, width on depth
            const dx = 80; // vertical spacing between nodes (increased for better visibility)
            const dy = 300; // horizontal spacing between levels (widened for adaptive widths)

            // Use d3.tree
            // Note: d3.tree().nodeSize([height, width]) because coordinates are flipped later? 
            // Actually, let's keep it simple. d3.tree creates x/y.
            // We want horizontal: Root at Left. 
            // In d3.tree, 'x' is usually vertical (top-to-bottom flow), 'y' is depth.
            // If we swap x and y in rendering, we get horizontal.

            const tree = d3.tree().nodeSize([dx, dy]);
            tree(root);

            // 1. Pre-calculate widths for all nodes
            root.descendants().forEach(d => {
                const title = d.data.title || "Untitled";
                // Estimate width: approx 14px per char + 40px padding
                // Cap min width at 120px, max at 400px
                d.width = Math.min(400, Math.max(120, title.length * 15 + 40));
                d.height = 40; // Fixed height
            });

            // 2. Compute tree layout (gives us x and initial y)
            tree(root);

            // 3. Adjust horizontal spacing (y) based on max width per level to prevent overlap
            const levelWidths = {};
            const levelGap = 120; // Gap between levels (increased for better spacing)

            // Find max width for each depth
            root.descendants().forEach(d => {
                const depth = d.depth;
                levelWidths[depth] = Math.max(levelWidths[depth] || 0, d.width);
            });

            // Calculate cumulative offset for each depth
            const levelOffsets = {};
            let currentOffset = 0;
            // Assuming max depth is reasonable
            const maxDepth = Math.max(...Object.keys(levelWidths).map(Number));

            for (let i = 0; i <= maxDepth; i++) {
                levelOffsets[i] = currentOffset;
                // Next level starts after this level's max width + gap
                currentOffset += (levelWidths[i] || 0) + levelGap;
            }

            // Apply new y coordinates
            root.descendants().forEach(d => {
                d.y = levelOffsets[d.depth];
            });

            // Compute global min/max to auto-center
            let x0 = Infinity;
            let x1 = -x0;
            root.each(d => {
                if (d.x > x1) x1 = d.x;
                if (d.x < x0) x0 = d.x;
            });

            // Adjust root vertical position to center it
            // After swap: d.x -> vertical (y), d.y -> horizontal (x)

            // Create links
            const links = state.g.selectAll(".link")
                .data(root.links())
                .join("path")
                .attr("class", "link")
                .attr("d", d3.linkHorizontal()
                    .x(d => d.y)
                    .y(d => d.x)
                );

            const node = state.g.selectAll(".node")
                .data(root.descendants())
                .join("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.y},${d.x})`)
                .on("click", (e, d) => scrollToTask(d.data.id));

            // We use 'each' to have context for measuring text if needed, 
            // but for simplicity and performance in this update, we will use estimation.

            node.each(function (d) {
                const g = d3.select(this);
                const title = d.data.title || "Untitled";
                // Estimate width: approx 14px per char + 40px padding
                // Cap min width at 100px, max at 400px
                const estimatedWidth = Math.min(400, Math.max(120, title.length * 15 + 40));
                const height = 40;

                // Background Rectangle (Simple Light Blue Pill)
                g.append("rect")
                    .attr("class", "node-rect")
                    .attr("rx", 20) // Fully rounded ends
                    .attr("ry", 20)
                    .attr("width", estimatedWidth)
                    .attr("height", height)
                    .attr("x", 0)
                    .attr("y", -height / 2)
                    .style("fill", "#e1f5fe") // Light Blue 50
                    .style("stroke", "#039be5") // Light Blue 600
                    .style("stroke-width", "2px");

                // Status Indicator (Small colored dot on the left)
                g.append("circle")
                    .attr("cx", 20)
                    .attr("cy", 0)
                    .attr("r", 6)
                    .attr("fill", statusColors[d.data.status || 'unknown']);

                // Text: Title
                g.append("text")
                    .attr("class", "node-title")
                    .attr("x", 35) // After the dot
                    .attr("y", 5) // Centered vertically
                    .text(title)
                    .style("font-size", "14px")
                    .style("font-weight", "500")
                    .style("fill", "#01579b"); // Dark Blue text
            });

            // Auto-Layout: Center the tree
            const container = document.getElementById('vis-container');
            const h = container.clientHeight;
            const w = container.clientWidth;

            // Initial transform
            // We want the root (which is at y=0, x=some_center) to be at the left-middle.
            // d.y is horizontal (starts at 0), d.x is vertical (centered around 0ish)

            // If the tree is large, d.x can range from -Large to +Large.
            // We want to translate such that the root node is at (50, h/2).
            const initialScale = 0.9;
            const transX = 50;
            const transY = h / 2 - root.x; // Shift by root's x-coordinate to center it?
            // Actually, d3.tree centers children. Root x is usually the midpoint of first and last child.
            // Wait, d3.tree with nodeSize lays out relative to (0,0) usually.
            // Let's just rely on zoomToFit logic if we had one, but let's try a simple center.

            state.svg.call(state.zoom.transform, d3.zoomIdentity.translate(50, h / 2).scale(0.8));
        }

        // --- List Rendering ---
        function renderTaskList(tasks) {
            // Sort tasks by updated_at in descending order (newest first)
            const sortedTasks = [...tasks].sort((a, b) => {
                const timeA = new Date(a.updated_at || a.created_at || 0);
                const timeB = new Date(b.updated_at || b.created_at || 0);
                return timeB - timeA;
            });

            const container = document.getElementById('tasks-list');

            // Create table HTML
            const tableHTML = `
                <div class="task-table-container">
                    <table class="task-table">
                        <thead>
                            <tr>
                                <th>Ê†áÈ¢ò</th>
                                <th>ÊèèËø∞</th>
                                <th>Áä∂ÊÄÅ</th>
                                <th>ÂàõÂª∫Êó∂Èó¥</th>
                                <th>Êõ¥Êñ∞Êó∂Èó¥</th>
                                <th>ID</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${sortedTasks.map(t => {
                const status = (t.status || 'pending').replace(/-/g, '_');
                const createdTime = formatTime(t.created_at);
                const updatedTime = formatTime(t.updated_at);

                return `
                                    <tr id="row-${t.id}" onclick="focusNode('${t.id}')">
                                        <td class="task-title-cell" title="${escapeHtml(t.title || 'Untitled')}">
                                            ${escapeHtml(t.title || 'Untitled')}
                                        </td>
                                        <td class="task-desc-cell" title="${escapeHtml(t.description || '')}">
                                            ${escapeHtml(t.description || '-')}
                                        </td>
                                        <td>
                                            <span class="task-status-badge status-${status}">
                                                ${status.replace(/_/g, '-')}
                                            </span>
                                        </td>
                                        <td class="task-time-cell">${createdTime}</td>
                                        <td class="task-time-cell">${updatedTime}</td>
                                        <td class="task-id-cell" title="${t.id}">
                                            ${t.id.substring(0, 8)}...
                                        </td>
                                    </tr>
                                `;
            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;

            container.innerHTML = tableHTML;
        }

        function formatTime(timeStr) {
            if (!timeStr) return '-';
            try {
                const date = new Date(timeStr);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);

                if (diffMins < 1) return 'ÂàöÂàö';
                if (diffMins < 60) return `${diffMins}ÂàÜÈíüÂâç`;
                if (diffHours < 24) return `${diffHours}Â∞èÊó∂Ââç`;
                if (diffDays < 7) return `${diffDays}Â§©Ââç`;

                // Format as YYYY-MM-DD HH:mm
                return date.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                return timeStr;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // --- Interactions ---
        function truncate(str, n) {
            return (str && str.length > n) ? str.substr(0, n - 1) + '&hellip;' : str;
        }

        function scrollToTask(id) {
            // Highlight in list
            const card = document.getElementById(`card-${id}`);
            if (card) {
                document.querySelectorAll('.task-card').forEach(c => c.classList.remove('active'));
                card.classList.add('active');
                card.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function focusNode(id) {
            // Find node in tree
            // Since we don't have a direct map from ID to D3 Node, we search. Not efficient but fine for small trees.
            // Or we could have indexed it.
            // Let's just log for now or try to finding it
            // console.log("Focusing node", id);
        }

        function zoomIn() {
            state.svg.transition().call(state.zoom.scaleBy, 1.2);
        }

        function zoomOut() {
            state.svg.transition().call(state.zoom.scaleBy, 0.8);
        }

        function resetZoom() {
            const container = document.getElementById('vis-container');
            state.svg.transition().call(state.zoom.transform,
                d3.zoomIdentity.translate(50, container.clientHeight / 2).scale(0.8));
        }

    </script>
</body>

</html>